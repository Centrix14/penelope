% Created 2024-01-04 Чт 20:11
% Intended LaTeX compiler: pdflatex
\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[russian]{babel}
\usepackage{indentfirst}
\author{Centrix14}
\date{\today}
\title{Статический анализатор типов «Penelope»\\\medskip
\large Итоговая работа по прикладной математике}
\hypersetup{
 pdfauthor={Centrix14},
 pdftitle={Статический анализатор типов «Penelope»},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.1 (Org mode 9.6.14)}, 
 pdflang={Russian}}
\begin{document}

\maketitle
\tableofcontents


\section{Вычисление типов значений}
\label{sec:orgcd85fea}
\subsection{Простое получение типов}
\label{sec:org10f08eb}
\begin{verbatim}
(let ((x 14))
  (list (type-of 1) (type-of 14) (type-of x)))
\end{verbatim}

Получается, что числа 0 и 1 считаются не числами, а битами. При том
\begin{verbatim}
(typep 1 'integer)
\end{verbatim}

Занятно!

\subsection{Безопасное вычисление типов}
\label{sec:orgcca81e1}
Чтобы вычислять типы безопасно и абстрагироваться от всяких там \texttt{BIT} и \texttt{SIMPLE-ARRAY} напишем свою функцию.

\begin{verbatim}
(defun ty (x)
  (typecase x
    (integer 'integer)
    (string 'string)
    (boolean 'boolean)
    (t (type-of x))))
\end{verbatim}

\texttt{ty} — это распространённое в профессиональной среде сокращение для слова \emph{type}. Так что тут всё с именованием нормально.

\section{Вычисление типов выражений}
\label{sec:orgfe437df}
\subsection{Простой обход дерева с определением типов}
\label{sec:orgaf38112}
Простая функция, которая обходит дерево и возвращает типы его частей.
\begin{verbatim}
(defun get-typed-tree (expr)
  (if (listp expr)
      (map 'list #'get-typed-tree expr)
      (ty expr)))
\end{verbatim}

Применим функцию.
\begin{verbatim}
(map 'list #'get-typed-tree
    '((1 t *)
      (* 2 2)
      (if (> x 2) x 2)
      (lambda (x) (* x 2))
      (max x 2)))
\end{verbatim}

\subsection{Работа в контексте}
\label{sec:org189b4cf}
Определение типов происходит в некотором контексте. Будем описывать его хэш-таблицей.
\begin{verbatim}
(defvar *env* (make-hash-table))
\end{verbatim}

Заполним контекст записями, где ключом будет название привязки, а значением — тип.
\begin{verbatim}
(map 'list
     (lambda (pair)
       (let ((variable (first pair))
             (type (second pair)))
         (setf (gethash variable *env*) type)
         pair))
     '((age integer)
       (name string)
       (+ math-op)
       (- math-op)
       (* math-op)
       (/ math-op)
       (> math-op)
       (< math-op)
       (= eq)
       (if if)
       (lambda lambda)))
\end{verbatim}

Как можно видеть, мы делаем необычную вещь — присваиваем типы ещё и различным операторам (функциям) языка.

\subsection{Обход дерева с учётом контекста}
\label{sec:orgb3b3989}
Теперь перепишем \texttt{get-typed-tree} с учётом контекста.
\begin{verbatim}
(defun get-typed-tree (expr env)
  (if (listp expr)
      (map 'list (lambda (x)
                   (get-typed-tree x env))
           expr)
      (let ((type (gethash expr env)))
        (if type
            type
            (ty expr)))))
\end{verbatim}

Проверим, как работает наша функция
\begin{verbatim}
(get-typed-tree '(> age 2) *env*)
\end{verbatim}

\subsection{Соотнесение типов}
\label{sec:orgfaa40b4}
Мы можем теперь определять типы выражений. Напишем же функцию, которая будет соотносить член выражения и его тип.
\begin{verbatim}
(defun assoc-type (expr env)
  (map 'list #'list expr (get-typed-tree expr env)))
\end{verbatim}

Посмотрим, что получилось.
\begin{verbatim}
(assoc-type '(if (> age 18) "Welcome!" "You too young...") *env*)
\end{verbatim}

\section{Полноценная проверка типов}
\label{sec:orga72b88a}
\subsection{Правила типизации}
\label{sec:orge30dc58}
Правила типизации так же будем хранить в хэш-таблице.
\begin{verbatim}
(defvar *rules* (make-hash-table :test #'equalp))
\end{verbatim}

Ключом будет предпосылка правила, а значением — вывод. Заполним таблицу.
\begin{verbatim}
(map 'list
     (lambda (rule)
       (let ((thesis (first rule))
             (conclusion (second rule)))
         (setf (gethash thesis *rules*) conclusion)))
     '(((math-op integer integer) integer)
       ((eq integer integer) boolean)
       ((if boolean integer integer) integer)
       ((if boolean boolean boolean) boolean)))
\end{verbatim}

\subsection{Получение типов по правилам}
\label{sec:org12a4b15}
Теперь напишем функцию, которая будет получать тип выражения на основе правил.
\begin{verbatim}
(defun get-type-from-rule (expr rules)
  (let ((type (gethash expr rules)))
    (if type
        type
        (error "Incorrect types in ~a~%" expr))))
\end{verbatim}

Проверим, как работают наши правила.
\begin{verbatim}
(get-type-from-rule '(math-op integer integer) *rules*)
\end{verbatim}

Всё работает как должно. Если ввести неверное правило, то мы получим ошибку.

Так мы получаем 2 части проверки типов: функцию расстановки типов в произвольном дереве и функцию вывода типа по правилам. Посмотрим, как они работают в тандеме.
\begin{verbatim}
(get-type-from-rule (get-typed-tree '(+ age 2) *env*) *rules*)
\end{verbatim}

Работает как и задумано. Теперь остаётся объединить наши функции, чтобы получить полноценную проверку типов.

\subsection{Проверка типов}
\label{sec:orgce7aa39}
По структуре, проверка типов будет такой же, как и \texttt{get-typed-tree}, мы лишь добавим вывод типов по правилам.
\begin{verbatim}
(defun type-check (rules env expr)
  (if (listp expr)
      (get-type-from-rule
       (map 'list (lambda (x)
                    (type-check rules env x))
            expr)
       rules)
      (let ((type (gethash expr env)))
        (if type
            type
            (ty expr)))))
\end{verbatim}

Посмотрим, как наша нехитрая конструкция работает.
\begin{verbatim}
(type-check *rules* *env* '(if (= age 18) t t))
\end{verbatim}

Тип выведен верно. Никаких ошибок нет. Есть только одна проблема: правило типизации для \texttt{if} мы записали следующим образом: \texttt{((if boolean int int) int)}. Далее мы добавляем: \texttt{((if boolean boolean boolean) boolean)}. Почему? Всё потому, что вообще правило для \texttt{if} необходимо дать в общем виде:

\[
\frac{\Gamma \vdash v1 : \textrm{t} \quad \Gamma \vdash v2 : \textrm{t}
\quad \Gamma \vdash c : \textrm{bool}}
{\Gamma \vdash \textrm{v1 if c else v2} : \textrm{t}}.
\]

Но наша система сделать этого не позволяет. Оно, на самом деле, и хорошо. Так мы можем точно и конкретно задать, какие типы могут участвовать в записи условных конструкций.
\end{document}
