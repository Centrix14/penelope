#+title: Статический анализатор типов «Penelope»
#+author: Centrix14
#+startup: overview

* Определение пакета
Чтобы не засорять пакет пользователя =cl-user= определим свой, рабочий пакет, где будут храниться все функции.
#+begin_src lisp :tangle penelope.lisp
  (defpackage :penelope
    (:use :cl))

  (in-package :penelope)
#+end_src

#+RESULTS:
: #<PACKAGE "PENELOPE">
* Вычисление типов значений
** Простое получение типов
Для начала просто изучим типизацию в Common Lisp. Сделать это можно при помощи функции =type-of=. Первое же исследование открывает интересные подробности:
#+begin_src lisp
  (let ((x 14))
    (list (type-of 1) (type-of 14) (type-of x)))
#+end_src

#+RESULTS:
| BIT | (INTEGER 0 4611686018427387903) | (INTEGER 0 4611686018427387903) |

Выходит, что 0 — это =BIT=, а вот 14 и x — =INTEGER=.

Получается, что числа 0 и 1 считаются не числами, а битами. При том
#+begin_src lisp
  (typep 1 'integer)
#+end_src

#+RESULTS:
: T

Утвердительно кивает. Получается, что 1 является и битом и числом.
Занятно!
** Безопасное вычисление типов
Чтобы вычислять типы безопасно и абстрагироваться от всяких там =BIT= и =SIMPLE-ARRAY= напишем свою функцию.
#+begin_src lisp :tangle penelope.lisp
  (defun ty (x)
    (typecase x
      (integer 'integer)
      (string 'string)
      (boolean 'boolean)
      (t (type-of x))))
#+end_src

#+RESULTS:
: TY

=ty= — это распространённое в профессиональной среде сокращение для слова /type/. Так что тут всё с именованием нормально.
* Вычисление типов выражений
** Простой обход дерева с определением типов
Используя =ty= мы можем написать функцию, которая обходит дерево (выражение) и определяет типы его элементов.
#+begin_src lisp
  (defun type-tree (expr)
    (if (listp expr)
        (map 'list #'type-tree expr)
        (ty expr)))
#+end_src

#+RESULTS:
: TYPE-TREE

Применим функцию.
#+begin_src lisp
  (map 'list #'type-tree
      '((1 t *)
        (* 2 2)
        (if (> x 2) x 2)
        (lambda (x) (* x 2))
        (max x 2)))
#+end_src

#+RESULTS:
| INTEGER | BOOLEAN                 | SYMBOL                  |         |
| SYMBOL  | INTEGER                 | INTEGER                 |         |
| SYMBOL  | (SYMBOL SYMBOL INTEGER) | SYMBOL                  | INTEGER |
| SYMBOL  | (SYMBOL)                | (SYMBOL SYMBOL INTEGER) |         |
| SYMBOL  | SYMBOL                  | INTEGER                 |         |
** Работа в контексте
Чтобы работать с переменными (на самом деле это будут не переменные, а привязки, константы) добавим контекст (окружение, environment).
#+begin_src lisp :tangle penelope.lisp
  (defvar *env* (make-hash-table))
#+end_src

#+RESULTS:
: *ENV*

Заполним контекст записями, где ключом будет название привязки, а значением — тип.
#+begin_src lisp :tangle penelope.lisp
  (map 'list
       (lambda (pair)
         (let ((variable (first pair))
               (type (second pair)))
           (setf (gethash variable *env*) type)
           pair))
       '((age integer)
         (name string)
         (+ math-op)
         (- math-op)
         (* math-op)
         (/ math-op)
         (> math-op)
         (< math-op)
         (= eq)
         (if if)
         (lambda lambda)))
#+end_src

#+RESULTS:
| AGE    | INTEGER |
| NAME   | STRING  |
| +      | MATH-OP |
| -      | MATH-OP |
| *      | MATH-OP |
| >      | MATH-OP |
| <      | MATH-OP |
| =      | EQ      |
| IF     | IF      |
| LAMBDA | LAMBDA  |

Для упрощения кода здесь я решил схитрить — в контекст включены ещё и некоторые ключевые слова.
** Обход дерева с учётом контекста
Теперь перепишем =type-tree= с учётом контекста.
#+begin_src lisp
  (defun type-tree (expr env)
    (if (listp expr)
        (map 'list (lambda (x)
                     (type-tree x env))
             expr)
        (let ((type (gethash expr env)))
          (if type
              type
              (ty expr)))))
#+end_src

#+RESULTS:
: TYPE-TREE

Проверим, как работает наша функция
#+begin_src lisp
  (type-tree '(> age 2) *env*)
#+end_src

#+RESULTS:
| MATH-OP | INTEGER | INTEGER |

Результат:
#+RESULTS:
** Соотнесение типов
Для удобства напишем функцию, которая будет ассоциировать элемент выражения и тип, ему соответствующий.
#+begin_src lisp
  (defun assoc-type (expr env)
    (map 'list #'list expr (type-tree expr env)))
#+end_src

#+RESULTS:
: ASSOC-TYPE

Посмотрим, что получилось.
#+begin_src lisp
  (assoc-type '(if (> age 18) "Welcome!" "You too young...") *env*)
#+end_src

#+RESULTS:
| IF               | IF                        |
| (> AGE 18)       | (MATH-OP INTEGER INTEGER) |
| Welcome!         | STRING                    |
| You too young... | STRING                    |

* Полноценная проверка типов
** Правила типизации
Правила типизации мы будем хранить в /ассоциативном списке/. Конечно, мы можем хранить их и в хэш-таблице, так будет даже удобней, но есть одна проблема. Хэш-таблица даже в CL структура достаточно деревянная. Произвольные предикаты сравнения использовать нельзя, изменить порядок сравнения и всё такое прочее нельзя. Поэтому берём более медленный, но гибкий =alist=.
#+begin_src lisp :tangle penelope.lisp
  (defvar *rules*
    '(((math-op integer integer) integer)
      ((eq integer integer) boolean)
      ((if boolean integer integer) integer)
      ((if boolean boolean boolean) boolean)))
#+end_src

#+RESULTS:
: *RULES*
** Получение типов по правилам
Теперь напишем функцию, которая будет получать тип выражения на основе правил.
#+begin_src lisp
  (defun type-by-rule (expr rules)
    (let ((rule (assoc expr rules :test #'equalp)))
      (if rule
          (second rule)
          (error "Incorrect types in ~a~%" expr))))
#+end_src

#+RESULTS:
: TYPE-BY-RULE

Проверим, как работают наши правила.
#+begin_src lisp
  (type-by-rule '(math-op integer integer) *rules*)
#+end_src

#+RESULTS:
: INTEGER

Всё работает как должно. Если ввести неверное правило, то мы получим ошибку.

Так мы получаем 2 части проверки типов: функцию расстановки типов в произвольном дереве и функцию вывода типа по правилам. Посмотрим, как они работают в тандеме.
#+begin_src lisp
  (type-by-rule (type-tree '(+ age 2) *env*) *rules*)
#+end_src

#+RESULTS:
: INTEGER

Работает как и задумано. Теперь остаётся объединить наши функции, чтобы получить полноценную проверку типов.
** Проверка типов
По структуре, проверка типов будет такой же, как и =type-tree=, мы лишь добавим вывод типов по правилам.
#+begin_src lisp
  (defun type-check (rules env expr)
    (if (listp expr)
        (type-by-rule
         (map 'list (lambda (x)
                      (type-check rules env x))
              expr)
         rules)
        (let ((type (gethash expr env)))
          (if type
              type
              (ty expr)))))
#+end_src

#+RESULTS:
: TYPE-CHECK

Посмотрим, как наша нехитрая конструкция работает.
#+begin_src lisp
  (type-check *rules* *env* '(if (= age 18) t t))
#+end_src

#+RESULTS:
: BOOLEAN

Тип выведен верно. Никаких ошибок нет. Есть только одна проблема: правило типизации для =if= мы записали следующим образом: =((if boolean int int) int)=. Далее мы добавляем: =((if boolean boolean boolean) boolean)=. Почему? Всё потому, что вообще правило для =if= необходимо дать в общем виде: =((if boolean t t) t)=.

Но наша система сделать этого не позволяет. Что же делать? Можно попробовать доработать нашу систему и ввести в неё обобщённые типы, но это напрасные усилия. Давайте в список правил кроме шаблонов включать и просто функции. Это позволит сделать нашу систему безумно гибкой.
** Функция получения типа для условных конструкций
Для начала напишем функцию, которая будет проверять типы в условных конструкциях.
#+begin_src lisp :tangle penelope.lisp
  (defun type-if (expr)
    (if (and (eql (first expr) 'if)
             (eql (second expr) 'boolean)
             (eql (third expr) (fourth expr)))
        (third expr)
        nil))
#+end_src

#+RESULTS:
: TYPE-IF

Проверим функцию.
#+begin_src lisp
  (map 'list #'type-if
       '((if boolean integer integer)
         (if boolean string string)
         (if boolean a b)))
#+end_src

#+RESULTS:
| INTEGER | STRING | NIL |
** Добавление функций в список правил
Теперь изменим список правил.
#+begin_src lisp :tangle penelope.lisp
  (setf *rules*
        `(((math-op integer integer) integer)
          ((eq integer integer) boolean)
          ,#'type-if))
#+end_src

#+RESULTS:
: (((MATH-OP INTEGER INTEGER) INTEGER) ((EQ INTEGER INTEGER) BOOLEAN)
:  #<FUNCTION TYPE-IF>)
** Улучшаем получение типов по правилам
Теперь нам осталось несколько переписать функцию для взятия типов по правилам.
#+begin_src lisp :tangle penelope.lisp
  (defun type-by-rule (expr rules)
    (if (null rules)
        (error "Expression ~a has incorrect types~%" expr)
        (let ((rule (car rules)))
          (if (functionp rule)
              (if (funcall rule expr)
                  (funcall rule expr)
                  (type-by-rule expr (cdr rules)))
              (if (equalp (first rule) expr)
                  (second rule)
                  (type-by-rule expr (cdr rules)))))))
#+end_src

#+RESULTS:
: TYPE-BY-RULE

#+begin_src lisp
  (map 'list
       (lambda (expr)
         (type-by-rule expr *rules*))
       '((math-op integer integer)
         (eq integer integer)
         (if boolean ty ty)))
#+end_src

#+RESULTS:
| INTEGER | BOOLEAN | TY |

** Функция проверки типов: окончание
Наконец, определим функцию проверки типов для новой системы работы с правилами.
#+begin_src lisp :tangle penelope.lisp
  (defun type-check (rules env expr)
    (if (listp expr)
        (type-by-rule
         (map 'list (lambda (x)
                      (type-check rules env x))
              expr)
         rules)
        (let ((type (gethash expr env)))
          (if type
              type
              (ty expr)))))
#+end_src

#+RESULTS:
: TYPE-CHECK
** Испытания проверки типов
А теперь испытаем наш код в реальном примере.
#+begin_src lisp
  (type-check *rules* *env*
              '(if (= 2 2)
                (+ (* 2 2) 2)
                (/ (- 150 4) 8)))
#+end_src

#+RESULTS:
: INTEGER
