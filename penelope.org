#+title: Статический анализатор типов «Penelope»
#+author: Centrix14
#+startup: overview

* Определение пакета
Определим пакет, в котором будем работать.
#+begin_src lisp :tangle penelope.lisp
  (defpackage :penelope
    (:use :cl))

  (in-package :penelope)
#+end_src
* Вычисление типов значений
** Простое получение типов
#+begin_src lisp
  (let ((x 14))
    (list (type-of 1) (type-of 14) (type-of x)))
#+end_src

#+RESULTS:
| BIT | (INTEGER 0 4611686018427387903) | (INTEGER 0 4611686018427387903) |

Получается, что числа 0 и 1 считаются не числами, а битами. При том
#+begin_src lisp
  (typep 1 'integer)
#+end_src

#+RESULTS:
: T

Занятно!

** Безопасное вычисление типов
Чтобы вычислять типы безопасно и абстрагироваться от всяких там =BIT= и =SIMPLE-ARRAY= напишем свою функцию.

#+begin_src lisp :tangle penelope.lisp
  (defun ty (x)
    (typecase x
      (integer 'integer)
      (string 'string)
      (boolean 'boolean)
      (t (type-of x))))
#+end_src

#+RESULTS:
: TY

=ty= — это распространённое в профессиональной среде сокращение для слова /type/. Так что тут всё с именованием нормально.

* Вычисление типов выражений
** Простой обход дерева с определением типов
Простая функция, которая обходит дерево и возвращает типы его частей.
#+begin_src lisp
  (defun get-typed-tree (expr)
    (if (listp expr)
        (map 'list #'get-typed-tree expr)
        (ty expr)))
#+end_src

#+RESULTS:
: GET-TYPED-TREE

Применим функцию.
#+begin_src lisp
  (map 'list #'get-typed-tree
      '((1 t *)
        (* 2 2)
        (if (> x 2) x 2)
        (lambda (x) (* x 2))
        (max x 2)))
#+end_src

#+RESULTS:
| INTEGER | BOOLEAN                 | SYMBOL                  |         |
| SYMBOL  | INTEGER                 | INTEGER                 |         |
| SYMBOL  | (SYMBOL SYMBOL INTEGER) | SYMBOL                  | INTEGER |
| SYMBOL  | (SYMBOL)                | (SYMBOL SYMBOL INTEGER) |         |
| SYMBOL  | SYMBOL                  | INTEGER                 |         |

** Работа в контексте
Определение типов происходит в некотором контексте. Будем описывать его хэш-таблицей.
#+begin_src lisp :tangle penelope.lisp
  (defvar *env* (make-hash-table))
#+end_src

#+RESULTS:
: *ENV*

Заполним контекст записями, где ключом будет название привязки, а значением — тип.
#+begin_src lisp :tangle penelope.lisp
  (map 'list
       (lambda (pair)
         (let ((variable (first pair))
               (type (second pair)))
           (setf (gethash variable *env*) type)
           pair))
       '((age integer)
         (name string)
         (+ math-op)
         (- math-op)
         (* math-op)
         (/ math-op)
         (> math-op)
         (< math-op)
         (= eq)
         (if if)
         (lambda lambda)))
#+end_src

#+RESULTS:
| AGE    | INTEGER |
| NAME   | STRING  |
| +      | MATH-OP |
| -      | MATH-OP |
| *      | MATH-OP |
| >      | MATH-OP |
| <      | MATH-OP |
| =      | EQ      |
| IF     | IF      |
| LAMBDA | LAMBDA  |

Как можно видеть, мы делаем необычную вещь — присваиваем типы ещё и различным операторам (функциям) языка.

** Обход дерева с учётом контекста
Теперь перепишем =get-typed-tree= с учётом контекста.
#+begin_src lisp
  (defun get-typed-tree (expr env)
    (if (listp expr)
        (map 'list (lambda (x)
                     (get-typed-tree x env))
             expr)
        (let ((type (gethash expr env)))
          (if type
              type
              (ty expr)))))
#+end_src

#+RESULTS:
: GET-TYPED-TREE

Проверим, как работает наша функция
#+begin_src lisp
  (get-typed-tree '(> age 2) *env*)
#+end_src

#+RESULTS:
| MATH-OP | INTEGER | INTEGER |

** Соотнесение типов
Мы можем теперь определять типы выражений. Напишем же функцию, которая будет соотносить член выражения и его тип.
#+begin_src lisp
  (defun assoc-type (expr env)
    (map 'list #'list expr (get-typed-tree expr env)))
#+end_src

#+RESULTS:
: ASSOC-TYPE

Посмотрим, что получилось.
#+begin_src lisp
  (assoc-type '(if (> age 18) "Welcome!" "You too young...") *env*)
#+end_src

#+RESULTS:
| IF               | IF                        |
| (> AGE 18)       | (MATH-OP INTEGER INTEGER) |
| Welcome!         | STRING                    |
| You too young... | STRING                    |

* Полноценная проверка типов
** Правила типизации
Правила типизации мы будем хранить в /ассоциативном списке/. Это по-началу может показаться странным, но позже мы поймём почему хэш-таблица не подходит.
#+begin_src lisp
  (defvar *rules*
    '(((math-op integer integer) integer)
      ((eq integer integer) boolean)
      ((if boolean integer integer) integer)
      ((if boolean boolean boolean) boolean)))
#+end_src

#+RESULTS:
: *RULES*

** Получение типов по правилам
Теперь напишем функцию, которая будет получать тип выражения на основе правил.
#+begin_src lisp
  (defun get-type-from-rule (expr rules)
    (let ((rule (assoc expr rules :test #'equalp)))
      (if rule
          (second rule)
          (error "Incorrect types in ~a~%" expr))))
#+end_src

#+RESULTS:
: GET-TYPE-FROM-RULE

Проверим, как работают наши правила.
#+begin_src lisp
  (get-type-from-rule '(math-op integer integer) *rules*)
#+end_src

#+RESULTS:
: INTEGER

Всё работает как должно. Если ввести неверное правило, то мы получим ошибку.

Так мы получаем 2 части проверки типов: функцию расстановки типов в произвольном дереве и функцию вывода типа по правилам. Посмотрим, как они работают в тандеме.
#+begin_src lisp
  (get-type-from-rule (get-typed-tree '(+ age 2) *env*) *rules*)
#+end_src

#+RESULTS:
: INTEGER

Работает как и задумано. Теперь остаётся объединить наши функции, чтобы получить полноценную проверку типов.

** Проверка типов
По структуре, проверка типов будет такой же, как и =get-typed-tree=, мы лишь добавим вывод типов по правилам.
#+begin_src lisp
  (defun type-check (rules env expr)
    (if (listp expr)
        (get-type-from-rule
         (map 'list (lambda (x)
                      (type-check rules env x))
              expr)
         rules)
        (let ((type (gethash expr env)))
          (if type
              type
              (ty expr)))))
#+end_src

#+RESULTS:
: TYPE-CHECK

Посмотрим, как наша нехитрая конструкция работает.
#+begin_src lisp
  (type-check *rules* *env* '(if (= age 18) t t))
#+end_src

#+RESULTS:
: BOOLEAN

Тип выведен верно. Никаких ошибок нет. Есть только одна проблема: правило типизации для =if= мы записали следующим образом: =((if boolean int int) int)=. Далее мы добавляем: =((if boolean boolean boolean) boolean)=. Почему? Всё потому, что вообще правило для =if= необходимо дать в общем виде:

\[
\frac{\Gamma \vdash v1 : \textrm{t} \quad \Gamma \vdash v2 : \textrm{t}
\quad \Gamma \vdash c : \textrm{bool}}
{\Gamma \vdash \textrm{v1 if c else v2} : \textrm{t}}.
\]

Но наша система сделать этого не позволяет. Что же делать? Можно попробовать доработать нашу систему и ввести в неё обобщённые типы, но это напрасные усилия. Давайте в список правил кроме шаблонов включать и просто функции. Это позволит сделать нашу систему безумно гибкой.

** Функция получения типа для условных конструкций
Для начала напишем функцию, которая будет проверять типы в условных конструкциях.
#+begin_src lisp :tangle penelope.lisp
  (defun if-typing (expr)
    (if (and (eql (first expr) 'if)
             (eql (second expr) 'boolean)
             (eql (third expr) (fourth expr)))
        (third expr)
        nil))
#+end_src

#+RESULTS:
: IF-TYPING

Проверим функцию.
#+begin_src lisp
  (map 'list #'if-typing
       '((if boolean integer integer)
         (if boolean string string)
         (if boolean a b)))
#+end_src

#+RESULTS:
| INTEGER | STRING | NIL |

** Добавление функций в список правил
Для начала давайте изменим список правил.
#+begin_src lisp :tangle penelope.lisp
  (defvar *rules*
    `(((math-op integer integer) integer)
      ((eq integer integer) boolean)
      ,#'if-typing))
#+end_src

#+RESULTS:
: *RULES*

** Улучшаем получение типов по правилам
Теперь нам осталось несколько переписать функцию для взятия типов по правилам.
#+begin_src lisp :tangle penelope.lisp
  (defun get-type-from-rule (expr rules)
    (if (null rules)
        (error "Expression ~a has incorrect types~%" expr)
        (let ((rule (car rules)))
          (if (functionp rule)
              (if (funcall rule expr)
                  (funcall rule expr)
                  (get-type-from-rule expr (cdr rules)))
              (if (equalp (first rule) expr)
                  (second rule)
                  (get-type-from-rule expr (cdr rules)))))))
#+end_src

#+RESULTS:
: GET-TYPE-FROM-RULE

#+begin_src lisp :results value latex
  (map 'list
       (lambda (expr)
         (get-type-from-rule expr *rules*))
       '((math-op integer integer)
         (eq integer integer)
         (if boolean ty ty)))
#+end_src

#+RESULTS:
#+begin_export latex
| INTEGER | BOOLEAN | TY |
#+end_export

** Функция проверки типов: окончание
Наконец, определим функцию проверки типов для новой системы работы с правилами.
#+begin_src lisp :tangle penelope.lisp
  (defun type-check (rules env expr)
    (if (listp expr)
        (get-type-from-rule
         (map 'list (lambda (x)
                      (type-check rules env x))
              expr)
         rules)
        (let ((type (gethash expr env)))
          (if type
              type
              (ty expr)))))
#+end_src

#+RESULTS:
: TYPE-CHECK

** Испытания проверки типов
А теперь испытаем наш код в реальном примере.
#+begin_src lisp
  (type-check *rules* *env*
              '(if (= 2 2)
                (+ (* 2 2) 2)
                (/ (- 150 4) 8)))
#+end_src

#+RESULTS:
: INTEGER
